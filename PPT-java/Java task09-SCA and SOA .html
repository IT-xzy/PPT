
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题,可以在/css/reveal/theme/中选择其他主题,目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>什么是SCA？什么是SOA？</h3>
			<p></P>
            <h4>Java小课堂 BY武汉分院</h4>
            <p>分享人:甘乐</p>
			<time>
				<script type="text/javascript"> 
						var today = new Date();
						document.write(today.toLocaleDateString())
				</script>
			</time>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
		
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p style="text-align:left">基于分布式架构的系统是一组相互独立但并行协同工作的计算机集合;
			对系统的用户来说,系统就象一台计算机一样”这两层意思.从硬件角度,每台机器都是自治的、独立的;从软件角度,用户感受是整体的、一致的.
			</p>
			<p style="text-align:left">分布式架构设计的核心理念是“并行拆分与横向扩展”,即按照一定维度将系统进行拆分,系统各部分松耦合并行运行,并建立起较为完善的横向扩展与容错恢复机制.
			</p>
		</section>
        
		<section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <p style="text-align:left"><b>1. SOA定义</b></p>
            <p style="text-align:left">Service-architecture.com将SOA定义为:“本质上是服务的集合.服务间彼此通信,这种通信可能是简单的数据传送,也可能是两个或更多的服务协调进行某些活动.服务间需要某些方法进行连接.所谓服务就是精确定义、封装完善、独立于其他服务所处环境和状态的函数.”
			</p>
			<p style="text-align:left">满足以下全部3个基本要素的应用被称为SOA的编程:
				<ul>
						<li>松散耦合</li>
						<li>粗粒度</li>
						<li>位置和传输协议透明</li>
				</ul>
			</p>
		</section>
		
		<section>
			<p style="text-align:left"><b>2.SOA核心理念</b></p>
			<p style="text-align:left">在SOA架构风格中,服务是最核心的抽象手段,业务被划分（组件化）为一系列粗粒度的业务服务和业务流程.业务服务相对独立、自包含、
			可重用,由一个或者多个分布的系统所实现,而业务流程由服务组装而来.一个"服务"定义了一个与业务功能或业务数据相关的接口,以及约束这个接口的服务契约.
			接口和契约采用中立、基于标准的方式进行定义,它独立于实现服务的硬件平台、操作系统和编程语言.
			</p>
        </section>
		<section>
			<p style="text-align:left"><b>2.SOA核心理念</b></p>
			<p style="text-align:left">这使得构建在不同系统中的服务可以以一种统一的和通用的方式进行交互、相互理解.除了这种不依赖于特定技术的中立特性,通过服务注册库
			（Service Registry）加上企业服务总线（Enterprise Service Bus）来支持动态查询、定位、路由和中介（Mediation）的能力,使得服务之间的交互是动态的,位置是透明
			的.技术和位置的透明性,使得服务的请求者和提供者之间高度解耦.
			</p>
        </section>
		
		<section>
            <p style="text-align:left"><b>3.SCA概述</b></p>
			<p style="text-align:left">SCA （Service Component Architecture）是为实现 SOA 而产生的一种规范.它提供了一种编程模型,能够十分方便、快速地来构建 SOA 所需的系统和应用.SCA 提出了一种组合应用（composite applications）的概念,这些组合可以是各种符合 SOA 规范的服务,
			或者是已经构建好的其他组合应用.通过这种灵活的编程方式,它可以很快地组装出各种所需的应用程序.
			</p>
			<p style="text-align:left">SCA基于这样的理念:将业务功能作为一系列的服务而提供,并由这一系列的服务组装起来的解决方案来满足特定业务需求.这些组合的应用既包括为应用而新创建的特定服务,也包括源自已已存在系统和应用的业务逻辑,这些业务逻辑作为组合构件的一部分被复用.
			</p>
        </section>
		
		<section>
            <p style="text-align:left"><b>4.SCA装配模型</b></p>
			<p style="text-align:left">SCA的基础工件就是component,它是SCA的构成单元.构件(component)由一个实现的可配置（implementation）实例所组成.在该构件中,实现是提供业务功能的程序代码片段.该业务功能作为服务(service)而提供,为其他构件所使用.实现也许依赖于由其他构件所
			提供的服务,这些依赖被称作”引用”(reference).实现可以有一个可设置的属性(properties),该属性是可以影响业务功能操作的数据值.构件通过提供属性值和连线(wire)到由其他构件提供服务的引用来配置实现.
			</p>
        </section>

		 <section>
            <p style="text-align:left"><b>4.SCA装配模型</b></p>
			<p style="text-align:left">SCA把在装配应用中的内容和联接称为组合构件（composite）.组合构件能包含构件,服务,引用,属性声明以及描述这些元素间连接的连线(wire).组合构件可以分组并连接以不同技术实现的构件,其允许为每个业务任务使用相应的技术.反过来,组合构件能作为完整
			的构件实现来使用:提供服务,依赖引用以及可设置的属性值.
			</p>

		 
         <section>
            <h3>3.常见问题</h3>
        </section>
        <section>
            <p style="text-align:center">SOA vs 微服务</p>
        </section>
		
        <section>
            <h3>4.解决方案</h3>
        </section>
        <section>
            <p style="text-align:left">
				<ul>
						<li>目的不同</li>
						<li>部署方式不同</li>
						<li>服务粒度不同</li>
				</ul>
			</p>
		</section>

        <section>
            <h3>5.编码实战</h3>
        </section>
			<section>
            <p style="text-align:center"><b>Java类如何提供SCA构件的实现</b></p>
        </section>
		
		<section>
            <p style="text-align:left"><b>5.1服务</b></p>
			<p style="text-align:left">基于Java类的构件实现可以提供一个或多个服务.
			</p>
			<p style="text-align:left">基于Java的实现所提供的服务,可以有一个按下列方法之一定义的接口:
			</p>
			<ul>
						<li>Java接口</li>
						<li>Java类</li>
						<li>产生自Web Services Description Language  (WSDL) portType的Java接口</li>
				</ul>
        </section>
		<section>
			<p style="text-align:left">Java实现类必须实现服务接口定义的所有操作.如果服务接口是用一个Java接口定义的,那么基于Java的构件要么实现此Java接口,要么实现接口的所有操作.
			</p>
			<p style="text-align:left">由Java类定义接口的服务（与Java接口相对）不是远程的.产生自WSDL portType的Java接口是远程的
			</p>
		 </section>
		 
		<section>
		 <p style="text-align:left"><b>5.2引用</b></p>
			<p style="text-align:left">引用可以通过注入或ComponentContext API获得.推荐尽可能使用注入方式来访问引用.
			</p>
			<p style="text-align:left">1) 引用注入, 通过使用@Reference注解,Java实现类型可以显式地指定其使用的引用.
			</p>
			<p style="text-align:left">2) 动态引用访问, 引用可以通过ComponentContext.getService()和ComponentContext.getServiceReference(..)方法来动态访问.
			</p>
        </section>

		<section>
		 <p style="text-align:left"><b>5.3属性</b></p>
			<p style="text-align:left">1) 属性注入, 属性可以通过注入或ComponentContext API来获得.Java实现类型可以通过使用@Property注解显式地指定其属性;
			</p>
			<p style="text-align:left">2) 动态属性访问,属性可以通过ComponentContext. getProperty ()方法来动态访问.
			</p>
        </section>

		<section>
		 <p style="text-align:left"><b>5.4实现实例的实例化</b></p>
			<p style="text-align:left">Java实现类必须提供一个public或protected的构造函数,SCA运行时用此构造函数实例化实现的实例.构造函数可以有参数,
			当存在参数时,SCA容器会在调用构造函数时传递可用的属性或引用值.未通过构造函数设置的任何属性或引用值,都将会在任一服务方法被调用之前,
			被设置给属性域或被传递给与其关联的setter方法.
			</p>
        </section>
		
		<section>
			<p style="text-align:left"><b>5.5实现作用域与生命周期回调</b></p>
			<p style="text-align:left">Java实现类型支持《SCA Java通用注解和API规范中》定义的所有作用域:STATELESS, REQUEST, CONVERSATION和COMPOSITE.
			实现通过使用@Scope注解指定它们的作用域. 当实现类未指定@Scope注解,则其作用域默认为STATELESS.
			</p>
			<p style="text-align:left">Java构件实现通过使用@Init和@Destroy注解分别指定init和destroy回调.
			</p>
        </section>
		
		<section>
			<p style="text-align:left"><b>5.6指定构件类型（component type）</b></p>
			<p style="text-align:left">对于Java实现类,构件类型一般都是直接由Java类内省而来.
			</p>
			<p style="text-align:left">在配置文件中对构件类型的指定是可选的.component type配置文件由加载Java类的同一个类加载器发现.配置文件必须在与实现的命名空间一致的目录下,并与Java类名相同,且以.componentType扩展名替代.class扩展名.
			</p>
        </section>
		
		 <section>
            <h3>6.扩展思考</h3>
        </section>
        <section>
			<p style="text-align:center"><b>SCA 与 Spring Framework整合</b></p>
			<p style="text-align:left">与 Spring bean 类似,SCA 组件可以包含到其他组件所提供的服务的引用,并且有一些属性可供配置.与 Spring 形成对比的是,SCA 是一种跨语言的分布式组件架构,
			它支持多种组件通信机制.通过将 Spring beans 发布为可由其他组件访问的服务并为 Spring beans 提供关联到其他（可能为远程）组件的服务的引用,SCA 可以扩展 Spring 组件的功能.
			</p>
		</section>
		<section>
			<p style="text-align:left">要将 SCA 与 Spring 相结合,一种有效的方法是使用 Spring 来构建 “粗粒度” 的服务组件实现,并引入到 SCA 中以便公开服务、关联服务组件以及处理异构和分布式系统.
			</p>
			<p style="text-align:left">易于测试组件是 Spring 的一项优异的特性.缺少 API 和注入技术导致您只能使用简单的模拟对象进行测试.SCA 在服务方面对此进行了补充,因为关于服务组件的 SCA 复合
			集可以方便地切换到模拟配置以进行测试.
			</p>
		 </section>
        
        <section>
            <h3>7.参考文献</h3>
			<p style="text-align:left"><a href="https://cwiki.apache.org//confluence/pages/viewpage.action?pageId=96720" target="_blank">1.《AssemblyModel 装配模型规范》《JavaComponentImplementation JAVA构件实现规范》《JavaAnnotationsAndAPIs JAVA通用注解和API规范》
			</p>
			<p style="text-align:left"><a href="https://www.ibm.com/developerworks/cn/webservices/lp/sca/" target="_blank">2.IBM developerworks技术专栏《SCA 专题》
			</p>
			<p style="text-align:left"><a href="https://www.ibm.com/developerworks/cn/webservices/0708_xinsheng/index1.html#ibm-pcon" target="_blank">3.《SOA:原理•方法•实践,第 1 部分: SOA 的基本概念》
			</p>
			<p style="text-align:left"><a href="https://www.ibm.com/developerworks/cn/opensource/os-springsca1/index.html#artrelatedtopics" target="_blank">4.《三剑客:Spring、SCA 和 Apache Tuscany》
			</p>
			<p style="text-align:left"><a href="http://dockone.io/article/1646" target="_blank">5.《微服务与SOA架构》
			</p>
		</section>
		
		<section>
            <h3>8.更多讨论</h3>
			<p style="text-align:center"><a href="" target="">今天的分享就到这里啦,欢迎大家提问和探讨~
			</p>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号,也可以使用代码slideNumber: 'c / t' ,表示当前页/总页数.
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式,可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL,即从右往左
    // 	fragments: true, // 全局开启和关闭碎片.
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒）,当设置成 0 的时候则禁止自动切换,该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果,有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度,default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>