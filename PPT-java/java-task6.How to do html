<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
	
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>nginx如何实现负载均衡？</h2>
			<p></p>
            <h3>java小课堂</h3>
            <p>马正</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p>当需要处理的请求量过大，连接数较多情况下服务器就成为了性能瓶颈，导致请求响应速度变慢，影响用户体验。解决之道是使用负载均衡，而
            性能优越且可靠的支持负载均衡的服务器非nginx莫属</p>

        </section>
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <h4>什么是负载均衡</h4>
			<p>
                负载平衡是搭建一个高可用环境基础设施的关键组件，通常用于提高网站的性能和可靠性,应用程序、数据库和其他服务跨多个服务器分配负载。
            </p>
            <p>无负载均衡的Web基础设施一般如下图所示：<br> <img src="https://assets.digitalocean.com/articles/HAProxy/web_server.png"><br></p>
		</section>

        <section>
            <h3>一般web基础设施存在的两个问题</h3>
            <p>1.当webServer宕机了，那么就无法访问yourdoman.com网站了</p>
            <p>2.当webServer面临大量请求时单个webServer的处理能力有限，会增加请求响应延迟时间，对于用户来说是非常差的体验</p>
        </section>

        <section>
            <h3>增加负载均衡及一台webServer容器解决</h3>
            <p>对于以上面临的问题，可通过增加一台负载均衡服务器及一台或多台webServer来解决</p>
            <a href="https://assets.digitalocean.com/articles/high-availability/Diagram_2.png">如图</a>
        </section>

        <section>
            <h3>问题转移到了负载均衡器身上</h3>
            <p>刚开始所说的web基础设施存在的问题转移到了负载均衡器身上。当负载均衡器出现了宕机或是请求非常大那么或多或少单个负载均衡器转发请求速度会变慢
            ，随机增加请求响应延迟时间</p>
        </section>

        <section>
            <h3>负载均衡集群解决</h3>
            <p>负载均衡器自身的单点故障可通过增加一个或多个解决。在谈论此之前，让我们先了解下负载均衡器时如何工作的</p>
        </section>

        <section>
            <h3>负载均衡器如何选择后端服务器</h3>
            <p>负载平衡器选择哪个服务器将请求转发是基于两个因素的结合。
                他们首先将确保任意一台服务器可以选择(能响应请求，未宕机),
                然后使用一个预先配置的规则选择健康的服务器将请求转发。
            </p>
        </section>

        <section>
            <h3>健康检查(确保后端服务器未宕机)</h3>
            <p>
                负载均衡器应该将请求转发给健康的后端服务器，那么负载均衡器是如何做到的呢？
                通过监控机制，后端服务器会将不健康(无法响应请求)的后端服务器从池中删除。
                监控机制是负载均衡器定期试图连接到后端服务器定义的协议和端口转发规则，以确保服务器在正常监听能响应请求。
                若后端服务器没有通过一次健康检查(未响应负载均衡器的连接请求)那么会从池中删除该后端服务器，请求也不会被转发该后端服务器，直到它响应才会加进池中。
            </p>
        </section>

        <section>
            <h3>负载均衡算法</h3>
            <p1>负载均衡算法决定了负载均衡器会如何选择后端服务器</p1>
            <p1>常见的分为3种,分别是Round Robin(轮询)，Least Connections(最少连接数)，Source(源地址hash)</p1>
        </section>

        <section>
            <p>1.Round Robin:这意味着后端服务器是被按顺序选中的。负载均衡器选择后端服务器列表中的第一个并将请求准发给它，接着将该后端服务器移动到列表最后一列以达到轮询的效果</p>
            <p>2.Least Connections:最少连接意味着负载均衡器将选择转发请求给处理请求数最低的后端服务器</p>
            <p>3.Source:负载平衡器将选择哪个服务器使用基于hash的源IP请求,例如访问者的IP地址。这种方法可以确保一个特定的用户将持续发送请求到到同一台服务器。</p>
        </section>

        <section>
            <h3>处理负载均衡器的单点故障</h3>
            <p>处理负载均衡器的单点故障是增加一台或多台负载均衡器，另一个负载均衡器可以连接到第一个形成一个集群。若想建立一个集群还必须得有一个浮动ip,以便能够对于
                不同的负载均衡器使用同一个IP和端口访问。如下图：
            </p>
            <img src="https://assets.digitalocean.com/articles/high_availability/ha-diagram-animated.gif">
        </section>

        <section>
            <h3>浮动Ip</h3>
            <p>简单来说就是在搭建高可用的环境时配置集群需要用到，使用一个浮动ip按照规则连接到其中一台负载均衡器，当某个负载均衡器宕机时能够快速将浮动ip连接到另一台负载均衡器
            </p>
        </section>

        <section>
            <h3>什么是Nginx</h3>
            <p>NGINX是web服务开放源码软件,反向代理缓存、负载平衡、流媒体等，作为web服务器性能优异可靠。
                Nginx主要是用来作负载均衡
            </p>
        </section>

        <section>
            <h3>什么是反向代理</h3>
            <p>
                简单来说就是隐藏了服务器，正向代理相反是隐藏了客户端。反向代理也叫负载均衡器，是为了实现负载均衡的。
            </p>
        </section>
         <section>
            <h3>3.常见问题</h3>
        </section>

        <section>
            <p> <p>1.如何使用nginx实现负载均衡</p>
            <p>2.如何配置负载均衡集群</p>
        </section>

        <section>
            <h3>4.解决方案</h3>
            <p>1.配置多个web Server Nginx作为负载均衡器分发请求</p>
            <p>配置多台Nginx，多台web Server并配置浮动IP</p>
        </section>

    <section>
            <h3>5.编码实战</h3>
            <p></p>
      </section>

        <section>
            <h3>6.扩展思考</h3>
        </section>


        <section>
            <h3>7.参考文献</h3>
            <p>Java UUID Demo: http://blog.csdn.net/carefree31441/article/details/3998553</p>
            <p>UUID: http://www.jianshu.com/p/d77f3ef0868a</p>
        </section>

        <section>
            <h3>8.更多讨论</h3>
            <p></p>
        </section>
        <section>
            <h4>鸣谢</h4>
            <p>感谢观看</p>
            <p><small>BY : 马正</small></p>
        </section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>